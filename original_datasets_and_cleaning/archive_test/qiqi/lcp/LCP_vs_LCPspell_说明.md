# LCP 和 LCPspell 距离差别说明（小白版）

## 1. 先搞清楚「参考序列」是什么

- **参考序列**：就是「我们选来做标杆」的那一条序列，所有「距离小 / 中 / 大」都是**相对于这条序列**算出来的。
- 在代码里，参考序列 = 数据里的**第一条序列**（`sequence_data.ids[0]`）。在你这个例子里，**参考序列的 ID = 16**。
- 表格里的三条「代表」：
  - **距离小**：序列 109 —— 和参考序列 16 的 LCPspell 距离**最小**
  - **距离中**：序列 248 —— 和参考序列 16 的 LCPspell 距离**中等**
  - **距离大**：序列 311 —— 和参考序列 16 的 LCPspell 距离**最大**

所以：**参考序列 = 16**，后面说的「和参考比」都是「和序列 16 比」。

---

## 2. 你的表格在说什么

| 代表   | 序列ID | LCP(参考, 该序列) | LCPspell(参考, 该序列) |
|--------|--------|-------------------|------------------------|
| 距离小 | 109    | 34.0              | 1.0                    |
| 距离中 | 248    | 40.0              | 7.5                    |
| 距离大 | 311    | 40.0              | 14.0                   |

- 两列距离都是：**参考序列 16** 与 **109 / 248 / 311** 之间的距离。
- LCP 和 LCPspell 的数字**不能直接互相比较**（量纲、含义都不同），但可以对比「谁近谁远」以及「为什么两种算法会给出不同结论」。

---

## 3. LCP：按「时间点」比 —— 关心「同一时刻」是否一样

- **做法**：把两条序列都按**同一批时间点**排好（例如年龄 15、16、17…），然后：
  - 第 1 个时间点：你什么状态、我什么状态 → 一样就继续；
  - 第 2 个时间点：再比；
  - …直到**第一次不一样**就停下。
- **距离**：和「从开头算起，有多少个时间点不一样」有关（具体公式会再做归一化等）。  
  可以简单记：**LCP 越大 = 在「时间点对齐」的意义上，两条序列越不像。**

**直觉**：  
LCP 在问：「在**同一年龄/同一时间**，你和我的状态是不是一样？」  
- 你 20 岁在读书、我 25 岁在读书 → 在「时间点对齐」下会被当成不一样（因为不是同一年）。  
所以 LCP 特别在乎**事件发生的时间是否对齐**。

**重要：LCP 的「公共前缀」是什么意思？为什么 109 和 16 不是距离 0？**  
- LCP 的「最长公共前缀」= **从第 1 个时间点开始，连续有多少个时间点两条序列的状态完全一样**。  
  它是「第 1 格比第 1 格、第 2 格比第 2 格……」这样一格一格比下去，**直到第一次出现不一样**就停，前面有多少格一样，L 就是多少。
- 所以不是说「15–19 岁这一段都是 S，所以公共前缀就是这 5 格」——LCP 会**继续往后比**：20 岁、21 岁……只要某一年两条序列状态还一样，L 就继续加 1；**只有从某一年开始第一次不一样了**，才停。  
  在你这个例子里，序列长度是 **25 个时间点**（n = m = 25），109 和 16 的 LCP 距离是 34。下面一步一步反推 L：

  **步骤 1**：距离公式是  
  $$\text{距离} = n + m - 2\times L$$  
  其中 n、m 是两条序列的长度，L 是公共前缀长度（从第 1 格开始连续一样的格数）。

  **步骤 2**：代入已知：距离 = 34，n = m = 25。  
  $$34 = 25 + 25 - 2\times L$$

  **步骤 3**：算右边。  
  $$34 = 50 - 2\times L$$

  **步骤 4**：解出 2×L。  
  $$2\times L = 50 - 34 = 16$$

  **步骤 5**：解出 L。  
  $$L = 16 \div 2 = 8$$

  **结论**：L = 8 表示**前 8 个时间点（22 岁）**两条序列状态完全一样，从**第 9 个时间点**起才第一次不一样。所以 15–19 岁一样只是前 5 格；第 6、7、8 格（例如 20、21、22 岁）如果也一样，LCP 会继续算进去，直到第 9 格第一次不同才停。
- **距离什么时候才是 0？**  
  距离 = (n + m − 2×L)。要距离为 0，必须 L = 全长（两条序列**每一格**都一模一样）。  
  109 和 16 从某一格开始就不一样了，所以 L 不是全长，距离就不是 0。  
  简单记：**LCP 距离 0 = 两条序列完全相同（每个时间点状态都一样）；只要有一格不一样，距离就大于 0。**

---

## 4. LCPspell：按「一段段状态」比 —— 关心「经历形态」和「每段多长」

- **做法**：先把每条序列变成一串 **spell**（一段段「同一状态」的区间），例如：
  - 序列 16：S 一段 → M0 一段 → M2 一段 → M3+ 一段 …
  - 然后**不看具体哪一年**，只比：
    - 第 1 段：你的状态 vs 我的状态（一样就继续）；
    - 第 2 段：再比；
    - …直到第一次不一样。
  - 若选「考虑时长」，还会在「同一段状态」上比较**这段持续了多久**（duration）。
- **距离**：和「有多少段对不上」以及「每段时长差多少」有关。  
  可以简单记：**LCPspell 数值越大 = 在「经历形态 + 每段长度」上，两条序列越不像。**

**直觉**：  
LCPspell 在问：「你的**人生阶段顺序**（先 S 再 M0 再…）和每段**大概多长**，跟我的像不像？」  
- 不关心你是 20 岁还是 25 岁进入 M0，只关心「第几段是 M0、这段有多长」。  
所以 LCPspell 更在乎**生命历程的形态和节奏**，而不是日历时间是否对齐。

**重要：LCPspell 怎么算？一步一步来（以 16 vs 109、16 vs 311 为例）**

- **第一步：把序列变成「spell 列表」**  
  每条序列先压成若干 **spell**（一段段同一状态的区间），每个 spell 记两件事：**状态**（如 S、M0、M1）和**这段持续了多久**（duration，如 5 年、2 年）。  
  例如序列 16 可能是：第 1 段 S 持续 5 年、第 2 段 M0 持续 1 年、第 3 段 M2 持续 3 年……；序列 109 也是若干段，每段有状态和时长。

- **第二步：按「第几段」对齐比，算 L 和 duration_penalty**  
  - 第 1 段：16 的状态 vs 109 的状态 —— 一样就继续，并记 **duration_penalty += |16 第 1 段时长 − 109 第 1 段时长|**；  
  - 第 2 段：同样比状态、一样就再加两段时长的差的绝对值到 duration_penalty；  
  - …直到**某一段状态不一样**或其中一条序列没段了，就停。  
  - 停的时候：**L = 前面「状态一样」的段数**；**duration_penalty = 所有已匹配段的两边时长差之和**（只对「状态相同」的那几段累加）。

- **第三步：代入 LCPspell 的原始距离公式**  
  $$\text{raw} = (n + m - 2\times L) + \text{expcost} \times \text{duration\_penalty}$$  
  其中：  
  - **n** = 序列 16 的 spell 个数；  
  - **m** = 序列 109 的 spell 个数；  
  - **L** = 从第 1 段开始连续「状态相同」的段数；  
  - **expcost** = 时长权（代码里默认 0.5），越大越惩罚「同状态但时长差很多」。

- **第四步：归一化**  
  一般用 maxdist = n + m，再按你选的 norm（如 gmean）把 raw 变成 0～1 之间的数，得到你看到的「LCPspell 归一化距离」。

**举例 1：16 vs 109（归一化后约 0.1，很近）**

- 假设 16 和 109 都有 **n = m = 5 段**，且**前 5 段状态完全一致**（都是 S→M0→M2→M3+ 这类顺序），则 **L = 5**。  
- 那么 (n + m − 2×L) = 10 − 10 = **0**，即「段数差异」部分为 0。  
- 原始距离就只剩「时长差异」：  
  $$\text{raw} = 0 + \text{expcost} \times \text{duration\_penalty}$$  
  若 expcost = 0.5，且 5 段里每段两边时长差不大（例如 duration_penalty 合计约 0.2），则 raw ≈ 0.1，归一化后约 **0.1**。  
- **结论**：16 和 109 的 **spell 形态完全一样**（L = 5），只是每段**持续时长略有不同**，所以 LCPspell 给很小的距离。

**举例 2：16 vs 311（归一化后 1.0，最远）**

- 假设 16 有 **n = 5 段**，311 有 **m = 6 段**，且**第 1 段状态就不同**（例如 16 第 1 段是 S，311 第 1 段是别的，或顺序不同），则 **L = 0**（没有从第 1 段起连续相同的状态）。  
- 那么  
  $$\text{raw} = (5 + 6 - 0) + \text{expcost} \times \text{duration\_penalty} = 11 + \text{expcost} \times 0 = 11$$  
  （L=0 时没有「匹配的段」，duration_penalty = 0。）  
- maxdist = n + m = 11，raw = 11，归一化后就是 **1.0**。  
- **结论**：16 和 311 从**第一段开始形态就不同**（L = 0），LCPspell 认为「完全不像」，所以给最大距离 1.0。

**和 LCP 的对比（加深理解）**

|        | LCP（按时间点） | LCPspell（按 spell） |
|--------|------------------|----------------------|
| 比什么 | 第 1 格、第 2 格…（同一时间点状态是否一样） | 第 1 段、第 2 段…（同一段的状态是否一样 + 每段时长差） |
| L 含义 | 前 L **个时间点**两条序列状态完全一样 | 前 L **段 spell** 状态完全一样（可再加时长惩罚） |
| 距离 0 | 每条**时间点**都相同 | 每条**段数相同、每段状态相同、每段时长也相同**（且 expcost×duration_penalty=0） |

所以：LCP 的「前缀」是**时间点**意义上的；LCPspell 的「前缀」是**段（spell）**意义上的，并且还能用 duration_penalty 区分「形态一样、但某段持续久一点/短一点」的差别。

---

## 5. 为什么 109 / 248 / 311 对参考 16 会有这样的差别？

### 5.1 序列 109（距离小）

- **LCP = 34**：在「时间点对齐」下，109 和 16 从某个时间点开始就对不上了，所以 LCP 给出一个不小的数（34）。
- **LCPspell = 1.0**：在「spell 顺序 + 时长」下，109 和 16 非常像（都是 S→M0→M2→M3+ 这类形态），所以 LCPspell 很小（1.0）。

**小结**：109 和 16 的**经历形态很像**，但**发生的时间点不完全对齐**，所以 LCP 觉得「有点远」，LCPspell 觉得「很近」。

---

### 5.2 序列 248（距离中）

- **LCP = 40**：和 16 在时间点上很早就不一样了，所以 LCP 给 40（和 311 一样大）。
- **LCPspell = 7.5**：248 中间多了一段 **D**，而且后面的阶段顺序也和 16 不一样，所以 LCPspell 给出中等距离 7.5。

**小结**：248 和 16 在「时间点」和「spell 形态」上都有明显差异；LCP 只看到「对不齐」，LCPspell 还能区分「多了一段 D、阶段顺序不同」。

---

### 5.3 序列 311（距离大）

- **LCP = 40**：同样，在时间点上和 16 很早就对不上了，所以 LCP 也是 40。
- **LCPspell = 14.0**：311 的 **S 段特别长**，后面的阶段顺序（M0→M1→M2→M3+）也和 16 不同，所以 LCPspell 给出最大距离 14.0。

**小结**：311 和 16 在「经历形态」和「每段时长」上差异最大，所以 LCPspell 把它标成「距离大」；LCP 只能说出「时间对不齐」，和 248 一样都是 40。

---

## 6. 一句话对比

| 算法      | 在比什么                         | 更关心什么                     |
|-----------|----------------------------------|--------------------------------|
| **LCP**   | 同一时间点上的状态是否相同       | 事件是否在**同一时刻**发生     |
| **LCPspell** | 一段段状态的顺序 + 每段多长   | **经历形态**和**每段持续时间** |

所以：  
- 两条序列「形态很像、但时间错开」→ LCP 可能给大距离，LCPspell 给小距离（如 109 vs 16）。  
- 两条序列「形态差很多、或某段特别长/短」→ LCPspell 会给出更大距离（如 248、311 vs 16），而 LCP 可能只到 40 就「封顶」了，区分不了 248 和 311。

**为什么 LCP 会「封顶」、区分不了 248 和 311？**  
LCP 只用到一件事：**从第一个时间点开始，连续有多少个时间点和参考序列一样**（公共前缀长度 L）。一旦在某个时间点「第一次不一样」，LCP 就停在那里，距离 = (n + m − 2×L)，后面再怎么不一样都不再管。  
对 248 和 311 来说，它们和 16 的**第一次失配**都发生在差不多早的时间点（即和 16 的公共前缀长度 L 相同），所以算出来的 LCP 距离都是 40。LCP 不关心「失配之后谁和 16 差得更多」——只看「从哪一时刻开始不一样」，因此无法区分「248 和 16 后面差很多」与「311 和 16 后面差很多」，两个都得到 40。

---

## 7. 归一化后的距离矩阵对比（便于直接比较）

对同一批四条序列（16、109、248、311）分别用 LCP 和 LCPspell 算距离，并做 **normalization**，得到大致在 0～1 之间的数值，便于对比两种算法的差异。

### LCP（归一化后，按时间点比）

|       | 16   | 109  | 248  | 311  |
|-------|------|------|------|------|
| **16**  | 0.00 | 0.68 | 0.80 | 0.80 |
| **109** |      | 0.00 | 0.80 | 0.80 |
| **248** |      |      | 0.00 | 0.76 |
| **311** |      |      |      | 0.00 |

（上三角；下三角与上三角对称，故省略。）

### LCPspell（归一化后，按 spell 比）

|       | 16   | 109  | 248    | 311   |
|-------|------|------|--------|-------|
| **16**  | 0.00 | 0.10 | 0.62   | 1.00  |
| **109** |      | 0.00 | 0.58   | 1.00  |
| **248** |      |      | 0.00   | 0.75  |
| **311** |      |      |        | 0.00  |

（上三角；下三角与上三角对称，故省略。）

### 两种算法的差异说明（以参考序列 16 为例）

| 对比对象   | LCP（归一化） | LCPspell（归一化） | 说明 |
|------------|----------------|---------------------|------|
| **16 vs 109** | 0.68           | **0.10**            | LCPspell 认为 109 和 16 **非常像**（经历形态、spell 顺序和时长接近）；LCP 认为「有点远」（0.68），因为按时间点对齐比时，从某一格开始就不一样了。 |
| **16 vs 248** | 0.80           | 0.62                | 两种算法都认为 248 和 16 有相当差距；LCPspell 还能给出中等距离（0.62），能区分「比 109 远、比 311 近」。 |
| **16 vs 311** | **0.80**       | **1.00**            | LCPspell 认为 311 和 16 **最不像**（归一化下 1.00）；LCP 也是 0.80，但和 248 的 0.80 **几乎一样**，无法区分谁和 16 更远。 |

**小结**：

- **109 vs 16**：LCP 给 0.68、LCPspell 给 0.10 → 形态很像时，LCPspell 更强调「像」，LCP 更强调「时间点对不齐」带来的距离。
- **248 vs 16、311 vs 16**：LCP 都是 0.80 左右（248 为 0.80，311 为 0.80）→ LCP **区分不了** 248 和 311 谁和 16 更远；LCPspell 给出 0.62 和 1.00 → 能清楚区分「248 中等远、311 最远」。
- 归一化后两种距离都在 roughly 0～1 之间，可以直接看**谁大谁小**；但 LCP 和 LCPspell 的**含义不同**（时间点对齐 vs 经历形态+时长），所以同一对序列在两个表里的数值会不同，这正是两种算法侧重点不同的体现。

---

## 8. 讲解时可以怎么说（口述版）

- 「我们选**序列 16** 当参考，看谁和它最像、谁最不像。」
- 「**LCP** 是『同一时间点比状态』：你 20 岁在干啥、我 20 岁在干啥，不一样就记一笔。所以很在乎**时间是否对齐**。」
- 「**LCPspell** 是『先看人生有几段、每段什么状态、每段多长』，不比具体哪年。所以更在乎**人生形态和节奏**。」
- 「109 和 16 经历很像，只是时间错开一点，所以 LCP 觉得远（34）、LCPspell 觉得近（1.0）。248 和 311 形态差更多，LCPspell 就给 7.5 和 14.0，能区分谁和 16 差最多。」

这样别人就能理解：**参考序列是谁、两种距离各在比什么、为什么同一对序列会得到不同的「远近」结论**。
