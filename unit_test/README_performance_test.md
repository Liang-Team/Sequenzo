# get_distance_matrix 大规模性能测试

这个测试套件专门用于测试 `get_distance_matrix` 函数在不同重复序列情况下的性能表现，**序列规模已扩展到4万**。

## 测试目标

主要关注以下场景：
1. **高重复序列**：40000个序列，只有2000个唯一序列（重复序列多，去重后序列少）
2. **中等规模**：10000个序列，5000个唯一序列（中等重复程度）
3. **低重复序列**：40000个序列，有32000个唯一序列（重复序列少，去重后序列多）
4. **无重复序列**：40000个序列，全部唯一（所有序列都唯一）

## 测试内容

### 性能指标
- **执行时间**：计算距离矩阵所需的时间
- **内存使用**：峰值内存使用量（仅完整版测试）
- **结果验证**：确保计算结果正确

### 测试方法
- **OMspell**：Optimal Matching with spell length（主要测试方法）

## 文件说明

### 测试文件
- `test_get_distance_matrix_performance.py`：完整版测试（需要额外依赖）
- `test_get_distance_matrix_simple.py`：简化版测试（只需要标准库）
- `run_performance_test.py`：运行脚本，可选择测试类型

### 依赖要求

#### 完整版测试
```bash
pip install psutil memory_profiler
```

#### 简化版测试
只需要标准库，无需额外安装。

## 运行测试

### 方法1：使用运行脚本（推荐）
```bash
cd unit_test
python run_performance_test.py
```

### 方法2：直接运行简化版测试
```bash
cd unit_test
python test_get_distance_matrix_simple.py
```

### 方法3：使用unittest
```bash
cd unit_test
python -m unittest test_get_distance_matrix_simple.TestGetDistanceMatrixPerformanceSimple
```

## 预期结果

### 性能预期
1. **高重复情况应该比无重复情况快**：因为去重后需要计算的序列对更少
2. **OMspell方法在不同重复程度下表现不同**：重复程度影响计算复杂度
3. **内存使用应该与唯一序列数相关**：唯一序列越多，内存使用越多

### 典型输出示例
```
============================================================
测试高重复序列情况（40000个序列，只有2000个唯一序列）
============================================================
去重后唯一序列数: 2000

=== 高重复序列 - OMspell方法 ===
总序列数: 40000
序列长度: 10
状态数: 5
执行时间: 45.23 秒
结果矩阵大小: (40000, 40000)

=== 高重复序列 - OMspell方法2 ===
总序列数: 40000
序列长度: 10
状态数: 5
执行时间: 12.15 秒
结果矩阵大小: (40000, 40000)

============================================================
测试中等规模数据（10000个序列，5000个唯一序列）
============================================================
去重后唯一序列数: 5000

=== 中等规模 - OMspell方法 ===
总序列数: 10000
序列长度: 10
状态数: 5
执行时间: 8.45 秒
结果矩阵大小: (10000, 10000)

=== 中等规模 - OMspell方法2 ===
总序列数: 10000
序列长度: 10
状态数: 5
执行时间: 2.31 秒
结果矩阵大小: (10000, 10000)

================================================================================
性能对比分析
================================================================================

执行时间对比（秒）:
--------------------------------------------------------------------------------
方法             高重复          中等规模        低重复          无重复          
--------------------------------------------------------------------------------
OMspell_1       45.23           8.45            180.45          220.67           
OMspell_2       12.15           2.31            45.23           55.89            

性能分析:
--------------------------------------------------
OMspell_1方法: 高重复比无重复快 4.88 倍
OMspell_2方法: 高重复比无重复快 4.60 倍
```

## 测试用例说明

### 1. 高重复序列测试
- **目的**：测试在大量重复序列情况下的性能
- **数据**：40000个序列，只有2000个唯一序列
- **预期**：应该比无重复情况快很多

### 2. 中等规模测试
- **目的**：测试中等规模数据的性能
- **数据**：10000个序列，5000个唯一序列
- **预期**：性能介于高重复和无重复之间

### 3. 低重复序列测试
- **目的**：测试在少量重复序列情况下的性能
- **数据**：40000个序列，有32000个唯一序列
- **预期**：性能接近无重复情况

### 4. 无重复序列测试
- **目的**：测试在所有序列都唯一情况下的性能
- **数据**：40000个序列，全部唯一
- **预期**：这是最慢的情况，作为基准

### 5. 边界情况测试
- **极小数据集**：100个序列，50个唯一
- **极大重复**：1000个序列，只有1个唯一

## 系统要求

### 内存要求
- **4万序列测试**：建议至少16GB内存
- **1万序列测试**：建议至少8GB内存
- **边界测试**：1GB内存即可

### 时间要求
- **完整测试**：可能需要数小时（取决于硬件配置）
- **单个测试**：几分钟到几十分钟不等

## 故障排除

### 常见问题

1. **ImportError: No module named 'psutil'**
   - 解决：安装依赖 `pip install psutil memory_profiler`
   - 或者使用简化版测试

2. **内存不足**
   - 解决：减少测试数据规模
   - 修改 `total_sequences` 参数
   - 或者只运行中等规模测试

3. **编译错误**
   - 解决：确保C++扩展正确编译
   - 运行 `python setup.py build_ext --inplace`

4. **测试时间过长**
   - 解决：先运行边界测试验证环境
   - 然后运行中等规模测试
   - 最后运行大规模测试

### 调试建议

1. **从小数据集开始**：先测试100-1000个序列
2. **检查编译状态**：确保C++扩展正常工作
3. **监控系统资源**：使用任务管理器观察内存和CPU使用
4. **分批测试**：不要一次性运行所有测试

## 性能优化建议

基于测试结果，可以考虑以下优化：

1. **预处理去重**：在计算距离矩阵前先去除重复序列
2. **缓存机制**：缓存已计算的距离值
3. **并行计算**：利用多核CPU并行处理
4. **OMspell算法优化**：根据数据特征优化OMspell算法参数
5. **内存优化**：使用稀疏矩阵或分块计算

## 扩展测试

可以基于这个框架添加更多测试：

1. **不同序列长度**：测试序列长度对性能的影响
2. **不同状态数**：测试状态数量对性能的影响
3. **OMspell参数优化**：测试不同OMspell参数对性能的影响
4. **更大规模数据**：测试更大规模数据的性能表现
5. **分布式计算**：测试在多机器环境下的性能

## 注意事项

⚠️ **重要提醒**：
- 4万序列的测试需要大量内存和计算时间
- 建议在性能较好的机器上运行
- 可以先运行中等规模测试验证环境
- 如果内存不足，可以修改测试参数减少序列数量
