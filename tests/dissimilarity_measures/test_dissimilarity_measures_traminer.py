"""
@Author  : Yuqi Liang 梁彧祺
@File    : test_dissimilarity_measures_traminer.py
@Time    : 2026/02/08 08:07
@Desc    :
Tests for dissimilarity measures vs TraMineR. All measures are covered in one module.

  - dyadic_children subset: OM variants, attribute-based (first 10 time cols for attribute).
  - Small synthetic data: TWED (4 sequences, 5 positions, 2 states).

Three main groups (with TraMineR ref comparison):
  1) OM variants: OM+INDELS, OM+INDELSLOG, OM+FUTURE, OM+FEATURES, OMtspell.
  2) Attribute-based: LCS, NMS, NMSMST, NMSSTSSoft, SVRspell.
  3) TWED: norm=none, nu=0.5, h=0.5, sm constant 2, indel=2 (hardcoded ref).

Additional "parameter config" tests (Parts 1b, 2b, 3b): same algorithms with different
parameter values (norm, indel, tpow, expcost, nu, h, prox, kweights). These also
compare against TraMineR; refs are generated by the same R scripts (extra outputs).
Run traminer_reference.R, traminer_reference_attribute.R, and traminer_twed_reference.R
to generate all ref_*.csv files.

Part 4: OMloc on country_life_expectancy_global_deciles (OMloc+TRATE, OMloc+CONSTANT).
Run traminer_reference_omloc_life.R to generate ref_omloc_trate_life.csv, ref_omloc_constant_life.csv.
"""
import os
import subprocess
import tempfile

import numpy as np
import pandas as pd
import pytest

from sequenzo import SequenceData
from sequenzo.datasets import load_dataset
from sequenzo.dissimilarity_measures import get_distance_matrix


# Number of rows to use (must match R script default)
NROWS = 10

# For attribute-based measures (NMS, NMSSTSSoft, SVRspell), use only first 10 time columns
# to avoid C++ overflow "Number of subsequences is getting too big" (double overflow in recurrence).
MAX_TIME_COLS_ATTRIBUTE = 10

# Directory of this test module (for R scripts and ref CSVs)
THIS_DIR = os.path.dirname(os.path.abspath(__file__))


def _dyadic_children_subset(nrows=NROWS, max_time_cols=None):
    """Load dyadic_children and return first nrows as DataFrame (same as lcp-lsog setup).
    If max_time_cols is set, only the first max_time_cols time columns are used (for attribute tests)."""
    df = load_dataset("dyadic_children")
    time_list = [c for c in df.columns if str(c).isdigit()]
    time_list = sorted(time_list, key=int)
    if max_time_cols is not None:
        time_list = time_list[:max_time_cols]
    df = df.head(nrows)
    return df, time_list


def _sequence_data_from_df(df, time_list):
    """Build SequenceData like lcp-lsog notebook: states 1..6, id_col dyadID."""
    states = [1, 2, 3, 4, 5, 6]
    return SequenceData(
        df,
        time=time_list,
        id_col="dyadID",
        states=states,
    )


def _country_life_expectancy_subset():
    """Load country_life_expectancy_global_deciles, return all data (no filtering, includes missing values)."""
    df = load_dataset("country_life_expectancy_global_deciles")
    time_list = [c for c in df.columns if str(c).isdigit()]
    time_list = sorted(time_list, key=int)
    return df, time_list


def _sequence_data_from_life_df(df, time_list):
    """Build SequenceData for country_life_expectancy. State order must match TraMineR seqstatl
    (alphanumeric: D1, D10, D2, ..., D9) and Missing for with.missing=TRUE consistency."""
    states = [
        "D1 (Very Low)",
        "D2",
        "D3",
        "D4",
        "D5",
        "D6",
        "D7",
        "D8",
        "D9",
        "D10 (Very High)",
    ]
    return SequenceData(
        df,
        time=time_list,
        id_col="country",
        states=states,
    )


def _run_r_reference(csv_path, nrows, outdir, script_name, timeout=60):
    """Run R script to generate ref_*.csv in outdir. Returns True if success."""
    r_script = os.path.join(THIS_DIR, script_name)
    if not os.path.isfile(r_script):
        return False
    try:
        result = subprocess.run(
            ["Rscript", r_script, csv_path, str(nrows), outdir],
            capture_output=True,
            text=True,
            timeout=timeout,
            cwd=THIS_DIR,
        )
    except (FileNotFoundError, subprocess.TimeoutExpired):
        return False
    if result.returncode != 0:
        return False
    return True


def _run_r_twed_reference(outdir):
    """Run TWED R script to generate ref_twed_*.csv in outdir. Returns True if success."""
    r_script = os.path.join(THIS_DIR, "traminer_twed_reference.R")
    if not os.path.isfile(r_script):
        return False
    try:
        result = subprocess.run(
            ["Rscript", r_script, outdir],
            capture_output=True,
            text=True,
            timeout=30,
            cwd=THIS_DIR,
        )
    except (FileNotFoundError, subprocess.TimeoutExpired):
        return False
    return result.returncode == 0


def _load_ref_matrix(outdir, name):
    """Load reference matrix from ref_<name>.csv (first column = row index/labels)."""
    path = os.path.join(outdir, f"ref_{name}.csv")
    if not os.path.isfile(path):
        return None
    df = pd.read_csv(path, index_col=0)
    # R write.csv row.names=TRUE often gives string index "16","19",...; unify to numeric to match Sequenzo (int)
    try:
        idx = pd.to_numeric(df.index, errors="coerce")
        if idx.notna().all() and (np.mod(idx, 1) == 0).all():
            df.index = idx.astype(np.int64)
        col = pd.to_numeric(df.columns, errors="coerce")
        if col.notna().all() and (np.mod(col, 1) == 0).all():
            df.columns = col.astype(np.int64)
    except Exception:
        pass
    return df


def _align_and_compare(D_seq, D_ref, atol=1e-6, rtol=1e-5):
    """Compare Sequenzo result D_seq with R ref D_ref. Align by index/columns then compare."""
    ref_aligned = D_ref.reindex(index=D_seq.index, columns=D_seq.columns)
    n = D_seq.shape[0]
    for i in range(n):
        for j in range(n):
            a = float(D_seq.iloc[i, j])
            b = ref_aligned.iloc[i, j]
            if pd.isna(b):
                raise AssertionError(f"({i},{j}): ref missing at ({D_seq.index[i]},{D_seq.columns[j]})")
            assert np.isclose(a, b, atol=atol, rtol=rtol), (
                f"({i},{j}): Sequenzo={a}, TraMineR={b}"
            )


def _assert_valid_distance_matrix(D, n_expected=None):
    """Assert D is a valid distance matrix: square, symmetric, non-negative, no NaN. Optional n_expected for shape."""
    assert isinstance(D, pd.DataFrame), "Result should be a DataFrame"
    n, m = D.shape
    assert n == m, f"Matrix must be square, got {n}x{m}"
    if n_expected is not None:
        assert n == n_expected, f"Expected {n_expected} rows/cols, got {n}"
    for i in range(n):
        for j in range(n):
            v = D.iloc[i, j]
            assert not np.isnan(v), f"D[{i},{j}] is NaN"
            assert v >= -1e-12, f"D[{i},{j}] = {v} should be non-negative"
    # Symmetry (allow small numerical error)
    for i in range(n):
        for j in range(i + 1, n):
            assert np.isclose(D.iloc[i, j], D.iloc[j, i], rtol=1e-9, atol=1e-12), (
                f"D[{i},{j}]={D.iloc[i,j]} vs D[{j},{i}]={D.iloc[j,i]}"
            )


# ---------------------------------------------------------------------------
# Fixtures: ref dir for OM variants vs ref dir for attribute-based measures
# ---------------------------------------------------------------------------

@pytest.fixture(scope="module")
def ref_dir_om():
    """Generate R reference matrices for OM variants, or use THIS_DIR if refs already exist."""
    ref_names = ["om_indels", "om_indelslog", "om_future", "om_features", "omtspell"]
    for name in ref_names:
        p = os.path.join(THIS_DIR, f"ref_{name}.csv")
        if os.path.isfile(p):
            return THIS_DIR
    df, _ = _dyadic_children_subset(NROWS)
    with tempfile.NamedTemporaryFile(suffix=".csv", delete=False) as f:
        df.to_csv(f.name, index=False)
        csv_path = f.name
    try:
        outdir = tempfile.mkdtemp()
        ok = _run_r_reference(csv_path, NROWS, outdir, "traminer_reference.R")
        if ok:
            return outdir
    finally:
        try:
            os.unlink(csv_path)
        except Exception:
            pass
    pytest.skip(
        "R/TraMineR not available; run Rscript traminer_reference.R to generate ref_om_*.csv in this directory"
    )


@pytest.fixture(scope="module")
def ref_dir_attribute():
    """Generate R reference matrices for attribute-based measures, or use THIS_DIR if refs exist."""
    ref_names = ["lcs", "nms", "nmsmst", "nmsstssoft", "svrspell"]
    for name in ref_names:
        p = os.path.join(THIS_DIR, f"ref_{name}.csv")
        if os.path.isfile(p):
            return THIS_DIR
    df, _ = _dyadic_children_subset(NROWS)
    with tempfile.NamedTemporaryFile(suffix=".csv", delete=False) as f:
        df.to_csv(f.name, index=False)
        csv_path = f.name
    try:
        outdir = tempfile.mkdtemp()
        ok = _run_r_reference(csv_path, NROWS, outdir, "traminer_reference_attribute.R")
        if ok:
            return outdir
    finally:
        try:
            os.unlink(csv_path)
        except Exception:
            pass
    pytest.skip(
        "R/TraMineR not available; run Rscript traminer_reference_attribute.R to generate ref_lcs.csv, ref_nms.csv, etc."
    )


@pytest.fixture(scope="module")
def ref_dir_twed():
    """Generate R reference matrices for TWED (Part 3b), or use THIS_DIR if refs exist."""
    if os.path.isfile(os.path.join(THIS_DIR, "ref_twed_nu01_h05.csv")):
        return THIS_DIR
    outdir = tempfile.mkdtemp()
    if _run_r_twed_reference(outdir):
        return outdir
    pytest.skip(
        "R/TraMineR not available; run Rscript traminer_twed_reference.R . to generate ref_twed_*.csv"
    )


@pytest.fixture(scope="module")
def ref_dir_omloc_life():
    """Generate R reference matrices for OMloc on country_life_expectancy (Part 4), or use THIS_DIR if refs exist."""
    for name in ["omloc_trate_life", "omloc_constant_life"]:
        p = os.path.join(THIS_DIR, f"ref_{name}.csv")
        if os.path.isfile(p):
            return THIS_DIR
    df, _ = _country_life_expectancy_subset()
    with tempfile.NamedTemporaryFile(suffix=".csv", delete=False) as f:
        df.to_csv(f.name, index=False)
        csv_path = f.name
    try:
        outdir = tempfile.mkdtemp()
        ok = _run_r_reference(
            csv_path, len(df), outdir, "traminer_reference_omloc_life.R", timeout=600
        )
        if ok:
            return outdir
    finally:
        try:
            os.unlink(csv_path)
        except Exception:
            pass
    pytest.skip(
        "R/TraMineR not available; run Rscript traminer_reference_omloc_life.R to generate ref_omloc_trate_life.csv, ref_omloc_constant_life.csv"
    )


@pytest.fixture
def seqdata_subset():
    """SequenceData from first NROWS of dyadic_children (same as R input)."""
    df, time_list = _dyadic_children_subset(NROWS)
    return _sequence_data_from_df(df, time_list)


@pytest.fixture
def seqdata_subset_attribute():
    """SequenceData for attribute-based tests: NROWS rows, first MAX_TIME_COLS_ATTRIBUTE time columns only.
    Matches traminer_reference_attribute.R (which uses 10 time cols to avoid C++ overflow)."""
    df, time_list = _dyadic_children_subset(NROWS, max_time_cols=MAX_TIME_COLS_ATTRIBUTE)
    return _sequence_data_from_df(df, time_list)


@pytest.fixture
def seqdata_life_subset():
    """SequenceData from full country_life_expectancy_global_deciles (all data, same as R input)."""
    df, time_list = _country_life_expectancy_subset()
    return _sequence_data_from_life_df(df, time_list)


# =============================================================================
# Part 1: OM variants (OM+INDELS, OM+INDELSLOG, OM+FUTURE, OM+FEATURES, OMtspell)
# =============================================================================

def test_om_variant_indels_matches_traminer(seqdata_subset, ref_dir_om):
    """OM variant: sm=INDELS, indel=auto, norm=maxlength vs TraMineR (state-dependent indel)."""
    D_ref = _load_ref_matrix(ref_dir_om, "om_indels")
    if D_ref is None:
        pytest.skip("ref_om_indels.csv not found")
    D = get_distance_matrix(
        seqdata_subset,
        method="OM",
        sm="INDELS",
        indel="auto",
        norm="maxlength",
    )
    assert D.shape[0] == D_ref.shape[0] and D.shape[1] == D_ref.shape[1]
    _align_and_compare(D, D_ref, atol=1e-6, rtol=1e-5)


def test_om_variant_indelslog_matches_traminer(seqdata_subset, ref_dir_om):
    """OM variant: sm=INDELSLOG, indel=auto, norm=maxlength vs TraMineR."""
    D_ref = _load_ref_matrix(ref_dir_om, "om_indelslog")
    if D_ref is None:
        pytest.skip("ref_om_indelslog.csv not found")
    D = get_distance_matrix(
        seqdata_subset,
        method="OM",
        sm="INDELSLOG",
        indel="auto",
        norm="maxlength",
    )
    _align_and_compare(D, D_ref, atol=1e-6, rtol=1e-5)


def test_om_variant_future_matches_traminer(seqdata_subset, ref_dir_om):
    """OM variant: sm=FUTURE (seqcost FUTURE), norm=maxlength vs TraMineR (6x6 state block)."""
    D_ref = _load_ref_matrix(ref_dir_om, "om_future")
    if D_ref is None:
        pytest.skip("ref_om_future.csv not found")
    D = get_distance_matrix(
        seqdata_subset,
        method="OM",
        sm="FUTURE",
        indel="auto",
        norm="maxlength",
    )
    _align_and_compare(D, D_ref, atol=1e-6, rtol=1e-5)


def test_om_variant_features_matches_traminer(seqdata_subset, ref_dir_om):
    """OM variant: sm=FEATURES (state_features one column 1..6), norm=maxlength vs TraMineR (Gower = daisy)."""
    D_ref = _load_ref_matrix(ref_dir_om, "om_features")
    if D_ref is None:
        pytest.skip("ref_om_features.csv not found")
    state_features = pd.DataFrame({"f1": [1, 2, 3, 4, 5, 6]})
    D = get_distance_matrix(
        seqdata_subset,
        method="OM",
        sm="FEATURES",
        indel="auto",
        norm="maxlength",
        state_features=state_features,
    )
    _align_and_compare(D, D_ref, atol=1e-6, rtol=1e-5)


def test_om_variant_omtspell_matches_traminer(seqdata_subset, ref_dir_om):
    """OM variant: OMtspell (OMspell + tokdep_coeff) with TRATE sm, norm=YujianBo vs TraMineR."""
    D_ref = _load_ref_matrix(ref_dir_om, "omtspell")
    if D_ref is None:
        pytest.skip("ref_omtspell.csv not found")
    nstates = 6
    D = get_distance_matrix(
        seqdata_subset,
        method="OMspell",
        sm="TRATE",
        indel="auto",
        norm="YujianBo",
        expcost=0.5,
        tokdep_coeff=np.ones(nstates),
    )
    _align_and_compare(D, D_ref, atol=1e-6, rtol=1e-5)


# ----- Part 1b: OM parameter configs (vs TraMineR) -----

def test_om_indels_norm_none_matches_traminer(seqdata_subset, ref_dir_om):
    """OM+INDELS with norm='none' vs TraMineR."""
    D_ref = _load_ref_matrix(ref_dir_om, "om_indels_norm_none")
    if D_ref is None:
        pytest.skip("ref_om_indels_norm_none.csv not found (run traminer_reference.R)")
    D = get_distance_matrix(
        seqdata_subset,
        method="OM",
        sm="INDELS",
        indel="auto",
        norm="none",
    )
    _align_and_compare(D, D_ref, atol=1e-6, rtol=1e-5)


def test_om_indels_scalar_indel_matches_traminer(seqdata_subset, ref_dir_om):
    """OM+INDELS with indel=1, norm='maxlength' vs TraMineR."""
    D_ref = _load_ref_matrix(ref_dir_om, "om_indels_indel1_maxlength")
    if D_ref is None:
        pytest.skip("ref_om_indels_indel1_maxlength.csv not found (run traminer_reference.R)")
    D = get_distance_matrix(
        seqdata_subset,
        method="OM",
        sm="INDELS",
        indel=1.0,
        norm="maxlength",
    )
    _align_and_compare(D, D_ref, atol=1e-6, rtol=1e-5)


def test_om_trate_norm_gmean_matches_traminer(seqdata_subset, ref_dir_om):
    """OM+TRATE with norm='gmean' vs TraMineR."""
    D_ref = _load_ref_matrix(ref_dir_om, "om_trate_gmean")
    if D_ref is None:
        pytest.skip("ref_om_trate_gmean.csv not found (run traminer_reference.R)")
    D = get_distance_matrix(
        seqdata_subset,
        method="OM",
        sm="TRATE",
        indel="auto",
        norm="gmean",
    )
    _align_and_compare(D, D_ref, atol=1e-6, rtol=1e-5)


def test_omtspell_expcost_03_matches_traminer(seqdata_subset, ref_dir_om):
    """OMtspell with expcost=0.3 vs TraMineR."""
    D_ref = _load_ref_matrix(ref_dir_om, "omtspell_expcost03")
    if D_ref is None:
        pytest.skip("ref_omtspell_expcost03.csv not found (run traminer_reference.R)")
    nstates = 6
    D = get_distance_matrix(
        seqdata_subset,
        method="OMspell",
        sm="TRATE",
        indel="auto",
        norm="YujianBo",
        expcost=0.3,
        tokdep_coeff=np.ones(nstates),
    )
    _align_and_compare(D, D_ref, atol=1e-6, rtol=1e-5)


def test_omtspell_expcost_07_matches_traminer(seqdata_subset, ref_dir_om):
    """OMtspell with expcost=0.7 vs TraMineR."""
    D_ref = _load_ref_matrix(ref_dir_om, "omtspell_expcost07")
    if D_ref is None:
        pytest.skip("ref_omtspell_expcost07.csv not found (run traminer_reference.R)")
    nstates = 6
    D = get_distance_matrix(
        seqdata_subset,
        method="OMspell",
        sm="TRATE",
        indel="auto",
        norm="YujianBo",
        expcost=0.7,
        tokdep_coeff=np.ones(nstates),
    )
    _align_and_compare(D, D_ref, atol=1e-6, rtol=1e-5)


# =============================================================================
# Part 2: Attribute-based measures (LCS, NMS, NMSMST, NMSSTSSoft, SVRspell)
# =============================================================================

def test_attribute_lcs_matches_traminer(seqdata_subset_attribute, ref_dir_attribute):
    """Attribute-based: LCS (longest common subsequence), norm=none vs TraMineR."""
    D_ref = _load_ref_matrix(ref_dir_attribute, "lcs")
    if D_ref is None:
        pytest.skip("ref_lcs.csv not found")
    D = get_distance_matrix(
        seqdata_subset_attribute,
        method="LCS",
        norm="none",
    )
    _align_and_compare(D, D_ref, atol=1e-6, rtol=1e-5)


def test_attribute_nms_matches_traminer(seqdata_subset_attribute, ref_dir_attribute):
    """Attribute-based: NMS with prox=identity (TraMineR requires prox), norm=none vs TraMineR."""
    D_ref = _load_ref_matrix(ref_dir_attribute, "nms")
    if D_ref is None:
        pytest.skip("ref_nms.csv not found")
    nstates = 6
    prox = np.eye(nstates, dtype=np.float64)
    D = get_distance_matrix(
        seqdata_subset_attribute,
        method="NMS",
        prox=prox,
        norm="none",
    )
    _align_and_compare(D, D_ref, atol=1e-5, rtol=1e-5)


def test_attribute_nmsmst_matches_traminer(seqdata_subset_attribute, ref_dir_attribute):
    """Attribute-based: NMSMST (spell duration), kweights=ones, norm=none vs TraMineR."""
    D_ref = _load_ref_matrix(ref_dir_attribute, "nmsmst")
    if D_ref is None:
        pytest.skip("ref_nmsmst.csv not found")
    D = get_distance_matrix(
        seqdata_subset_attribute,
        method="NMSMST",
        norm="none",
    )
    _align_and_compare(D, D_ref, atol=1e-5, rtol=1e-5)


def test_attribute_nmsstssoft_matches_traminer(seqdata_subset_attribute, ref_dir_attribute):
    """Attribute-based: NMS with proximity (NMSSTSSoft / soft matching), prox=identity, norm=none vs TraMineR."""
    D_ref = _load_ref_matrix(ref_dir_attribute, "nmsstssoft")
    if D_ref is None:
        pytest.skip("ref_nmsstssoft.csv not found")
    nstates = 6
    prox = np.eye(nstates, dtype=np.float64)
    D = get_distance_matrix(
        seqdata_subset_attribute,
        method="NMS",
        prox=prox,
        norm="none",
    )
    _align_and_compare(D, D_ref, atol=1e-5, rtol=1e-5)


def test_attribute_svrspell_matches_traminer(seqdata_subset_attribute, ref_dir_attribute):
    """Attribute-based: SVRspell (spell-based with prox), default prox=identity, norm=none vs TraMineR."""
    D_ref = _load_ref_matrix(ref_dir_attribute, "svrspell")
    if D_ref is None:
        pytest.skip("ref_svrspell.csv not found")
    D = get_distance_matrix(
        seqdata_subset_attribute,
        method="SVRspell",
        norm="none",
    )
    _align_and_compare(D, D_ref, atol=1e-5, rtol=1e-5)


# ----- Part 2b: Attribute-based parameter configs (vs TraMineR) -----

def test_attribute_lcs_norm_gmean_matches_traminer(seqdata_subset_attribute, ref_dir_attribute):
    """LCS with norm='gmean' vs TraMineR."""
    D_ref = _load_ref_matrix(ref_dir_attribute, "lcs_gmean")
    if D_ref is None:
        pytest.skip("ref_lcs_gmean.csv not found (run traminer_reference_attribute.R)")
    D = get_distance_matrix(
        seqdata_subset_attribute,
        method="LCS",
        norm="gmean",
    )
    _align_and_compare(D, D_ref, atol=1e-5, rtol=1e-5)


def test_attribute_nms_prox_offdiag_matches_traminer(seqdata_subset_attribute, ref_dir_attribute):
    """NMS with prox=0.5*I + 0.5/n off-diagonal vs TraMineR."""
    D_ref = _load_ref_matrix(ref_dir_attribute, "nms_prox_offdiag")
    if D_ref is None:
        pytest.skip("ref_nms_prox_offdiag.csv not found (run traminer_reference_attribute.R)")
    nstates = 6
    prox = np.eye(nstates, dtype=np.float64) * 0.5 + (1.0 - 0.5) / nstates
    D = get_distance_matrix(
        seqdata_subset_attribute,
        method="NMS",
        prox=prox,
        norm="none",
    )
    _align_and_compare(D, D_ref, atol=1e-5, rtol=1e-5)


def test_attribute_nmsmst_tpow05_matches_traminer(seqdata_subset_attribute, ref_dir_attribute):
    """NMSMST with tpow=0.5 vs TraMineR."""
    D_ref = _load_ref_matrix(ref_dir_attribute, "nmsmst_tpow05")
    if D_ref is None:
        pytest.skip("ref_nmsmst_tpow05.csv not found (run traminer_reference_attribute.R)")
    D = get_distance_matrix(
        seqdata_subset_attribute,
        method="NMSMST",
        norm="none",
        tpow=0.5,
    )
    _align_and_compare(D, D_ref, atol=1e-5, rtol=1e-5)


def test_attribute_nmsmst_tpow2_matches_traminer(seqdata_subset_attribute, ref_dir_attribute):
    """NMSMST with tpow=2.0 vs TraMineR."""
    D_ref = _load_ref_matrix(ref_dir_attribute, "nmsmst_tpow2")
    if D_ref is None:
        pytest.skip("ref_nmsmst_tpow2.csv not found (run traminer_reference_attribute.R)")
    D = get_distance_matrix(
        seqdata_subset_attribute,
        method="NMSMST",
        norm="none",
        tpow=2.0,
    )
    _align_and_compare(D, D_ref, atol=1e-5, rtol=1e-5)


def test_attribute_svrspell_tpow05_matches_traminer(seqdata_subset_attribute, ref_dir_attribute):
    """SVRspell with tpow=0.5 vs TraMineR."""
    D_ref = _load_ref_matrix(ref_dir_attribute, "svrspell_tpow05")
    if D_ref is None:
        pytest.skip("ref_svrspell_tpow05.csv not found (run traminer_reference_attribute.R)")
    D = get_distance_matrix(
        seqdata_subset_attribute,
        method="SVRspell",
        norm="none",
        tpow=0.5,
    )
    _align_and_compare(D, D_ref, atol=1e-5, rtol=1e-5)


def test_attribute_svrspell_tpow2_matches_traminer(seqdata_subset_attribute, ref_dir_attribute):
    """SVRspell with tpow=2.0 vs TraMineR."""
    D_ref = _load_ref_matrix(ref_dir_attribute, "svrspell_tpow2")
    if D_ref is None:
        pytest.skip("ref_svrspell_tpow2.csv not found (run traminer_reference_attribute.R)")
    D = get_distance_matrix(
        seqdata_subset_attribute,
        method="SVRspell",
        norm="none",
        tpow=2.0,
    )
    _align_and_compare(D, D_ref, atol=1e-5, rtol=1e-5)


def test_attribute_nmsmst_kweights_matches_traminer(seqdata_subset_attribute, ref_dir_attribute):
    """NMSMST with custom kweights (first 2, rest 0.5) vs TraMineR."""
    D_ref = _load_ref_matrix(ref_dir_attribute, "nmsmst_kweights")
    if D_ref is None:
        pytest.skip("ref_nmsmst_kweights.csv not found (run traminer_reference_attribute.R)")
    ncols = MAX_TIME_COLS_ATTRIBUTE
    kweights = np.ones(ncols, dtype=np.float64) * 0.5
    kweights[0] = 2.0
    D = get_distance_matrix(
        seqdata_subset_attribute,
        method="NMSMST",
        norm="none",
        kweights=kweights,
    )
    _align_and_compare(D, D_ref, atol=1e-5, rtol=1e-5)


# =============================================================================
# Part 3: TWED (Time Warp Edit Distance)
# =============================================================================
# Reference from TraMineR (traminer_twed_reference.R): norm="none", nu=0.5, h=0.5,
# sm=[[0,2],[2,0]], indel=2. 4 sequences: (1,1,2,2,1), (1,2,2,1,1), (2,1,1,2,2), (1,1,1,2,2).

TRAMINER_TWED_REF = {
    (0, 1): 5.0,
    (0, 2): 9.0,
    (0, 3): 5.0,
    (1, 2): 13.0,
    (1, 3): 9.0,
    (2, 3): 4.0,
}


def _make_twed_test_data():
    """Synthetic 4 x 5 sequences (states 1, 2) for TWED vs TraMineR."""
    raw = np.array(
        [[1, 1, 2, 2, 1], [1, 2, 2, 1, 1], [2, 1, 1, 2, 2], [1, 1, 1, 2, 2]],
        dtype=int,
    )
    time_cols = ["C1", "C2", "C3", "C4", "C5"]
    df = pd.DataFrame(raw, columns=time_cols)
    df.insert(0, "id", ["s0", "s1", "s2", "s3"])
    return SequenceData(df, time=time_cols, states=[1, 2], id_col="id")


def test_twed_matches_traminer_pairwise():
    """TWED (norm=none, nu=0.5, h=0.5, sm constant 2, indel=2) vs TraMineR reference."""
    seqdata = _make_twed_test_data()
    sm = np.array([[0.0, 2.0], [2.0, 0.0]])
    D = get_distance_matrix(
        seqdata,
        method="TWED",
        norm="none",
        nu=0.5,
        h=0.5,
        sm=sm,
        indel=2,
    )
    assert D.shape == (4, 4)
    for (i, j), ref in TRAMINER_TWED_REF.items():
        got = D.iloc[i, j]
        assert np.isclose(got, ref, rtol=0, atol=1e-9), f"D[{i},{j}] got {got}, ref {ref}"


def test_twed_matches_traminer_refseq_sets():
    """TWED with refseq (two sets) matches the corresponding block from full pairwise matrix."""
    seqdata = _make_twed_test_data()
    sm = np.array([[0.0, 2.0], [2.0, 0.0]])
    kw = dict(method="TWED", norm="none", nu=0.5, h=0.5, sm=sm, indel=2)
    D_full = get_distance_matrix(seqdata, **kw)
    D_ref = get_distance_matrix(seqdata, refseq=[[0, 1], [2, 3]], **kw)
    assert D_ref.shape == (2, 2)
    assert np.isclose(D_ref.iloc[0, 0], D_full.iloc[0, 2], rtol=0, atol=1e-9)
    assert np.isclose(D_ref.iloc[0, 1], D_full.iloc[0, 3], rtol=0, atol=1e-9)
    assert np.isclose(D_ref.iloc[1, 0], D_full.iloc[1, 2], rtol=0, atol=1e-9)
    assert np.isclose(D_ref.iloc[1, 1], D_full.iloc[1, 3], rtol=0, atol=1e-9)


# ----- Part 3b: TWED parameter configs (vs TraMineR) -----

def test_twed_nu01_h05_matches_traminer(ref_dir_twed):
    """TWED nu=0.1, h=0.5 vs TraMineR."""
    D_ref = _load_ref_matrix(ref_dir_twed, "twed_nu01_h05")
    if D_ref is None:
        pytest.skip("ref_twed_nu01_h05.csv not found (run traminer_twed_reference.R)")
    seqdata = _make_twed_test_data()
    sm = np.array([[0.0, 2.0], [2.0, 0.0]])
    D = get_distance_matrix(seqdata, method="TWED", norm="none", nu=0.1, h=0.5, sm=sm, indel=2)
    _align_and_compare(D, D_ref, atol=1e-6, rtol=1e-5)


def test_twed_nu1_h01_matches_traminer(ref_dir_twed):
    """TWED nu=1.0, h=0.1 vs TraMineR."""
    D_ref = _load_ref_matrix(ref_dir_twed, "twed_nu1_h01")
    if D_ref is None:
        pytest.skip("ref_twed_nu1_h01.csv not found (run traminer_twed_reference.R)")
    seqdata = _make_twed_test_data()
    sm = np.array([[0.0, 2.0], [2.0, 0.0]])
    D = get_distance_matrix(seqdata, method="TWED", norm="none", nu=1.0, h=0.1, sm=sm, indel=2)
    _align_and_compare(D, D_ref, atol=1e-6, rtol=1e-5)


def test_twed_nu1_h1_matches_traminer(ref_dir_twed):
    """TWED nu=1.0, h=1.0 vs TraMineR."""
    D_ref = _load_ref_matrix(ref_dir_twed, "twed_nu1_h1")
    if D_ref is None:
        pytest.skip("ref_twed_nu1_h1.csv not found (run traminer_twed_reference.R)")
    seqdata = _make_twed_test_data()
    sm = np.array([[0.0, 2.0], [2.0, 0.0]])
    D = get_distance_matrix(seqdata, method="TWED", norm="none", nu=1.0, h=1.0, sm=sm, indel=2)
    _align_and_compare(D, D_ref, atol=1e-6, rtol=1e-5)


def test_twed_norm_yujianbo_matches_traminer(ref_dir_twed):
    """TWED norm='YujianBo', nu=0.5, h=0.5 vs TraMineR."""
    D_ref = _load_ref_matrix(ref_dir_twed, "twed_yujianbo")
    if D_ref is None:
        pytest.skip("ref_twed_yujianbo.csv not found (run traminer_twed_reference.R)")
    seqdata = _make_twed_test_data()
    sm = np.array([[0.0, 2.0], [2.0, 0.0]])
    D = get_distance_matrix(seqdata, method="TWED", norm="YujianBo", nu=0.5, h=0.5, sm=sm, indel=2)
    _align_and_compare(D, D_ref, atol=1e-6, rtol=1e-5)


def test_twed_indel1_matches_traminer(ref_dir_twed):
    """TWED indel=1, nu=0.5, h=0.5 vs TraMineR."""
    D_ref = _load_ref_matrix(ref_dir_twed, "twed_indel1")
    if D_ref is None:
        pytest.skip("ref_twed_indel1.csv not found (run traminer_twed_reference.R)")
    seqdata = _make_twed_test_data()
    sm = np.array([[0.0, 2.0], [2.0, 0.0]])
    D = get_distance_matrix(seqdata, method="TWED", norm="none", nu=0.5, h=0.5, sm=sm, indel=1.0)
    _align_and_compare(D, D_ref, atol=1e-6, rtol=1e-5)


# =============================================================================
# Part 4: OMloc on country_life_expectancy_global_deciles (OMloc+TRATE, OMloc+CONSTANT)
# =============================================================================

def test_omloc_trate_country_life_matches_traminer(seqdata_life_subset, ref_dir_omloc_life):
    """OMloc + TRATE on country_life_expectancy_global_deciles vs TraMineR (expcost=0.5, norm=YujianBo)."""
    D_ref = _load_ref_matrix(ref_dir_omloc_life, "omloc_trate_life")
    if D_ref is None:
        pytest.skip("ref_omloc_trate_life.csv not found (run traminer_reference_omloc_life.R)")
    D = get_distance_matrix(
        seqdata_life_subset,
        method="OMloc",
        sm="TRATE",
        indel="auto",
    )
    _align_and_compare(D, D_ref, atol=1e-6, rtol=1e-5)


def test_omloc_constant_country_life_matches_traminer(seqdata_life_subset, ref_dir_omloc_life):
    """OMloc + CONSTANT on country_life_expectancy_global_deciles vs TraMineR (cval=2, expcost=0.5, norm=YujianBo)."""
    D_ref = _load_ref_matrix(ref_dir_omloc_life, "omloc_constant_life")
    if D_ref is None:
        pytest.skip("ref_omloc_constant_life.csv not found (run traminer_reference_omloc_life.R)")
    D = get_distance_matrix(
        seqdata_life_subset,
        method="OMloc",
        sm="CONSTANT",
        indel=1,
    )
    _align_and_compare(D, D_ref, atol=1e-6, rtol=1e-5)
