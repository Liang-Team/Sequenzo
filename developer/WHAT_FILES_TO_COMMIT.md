# 开发者指南：哪些文件应该 Commit 到 Git？

## 快速答案

### ✅ 应该 Commit（源代码）

```
sequenzo/dissimilarity_measures/
├── __init__.py                    ✅ Python 源码
├── get_distance_matrix.py         ✅ Python 源码
├── get_substitution_cost_matrix.py ✅ Python 源码
├── src/
│   ├── module.cpp                 ✅ 手写的 C++ 源码（pybind11）
│   ├── OMdistance.cpp             ✅ 手写的 C++ 源码
│   ├── DHDdistance.cpp            ✅ 手写的 C++ 源码
│   ├── LCPdistance.cpp            ✅ 手写的 C++ 源码
│   ├── utils.h                    ✅ 手写的头文件
│   └── dp_utils.h                 ✅ 手写的头文件
└── utils/
    ├── __init__.py                ✅ Python 源码
    ├── get_LCP_length_for_2_seq.py ✅ Python 源码
    ├── seqconc.pyx                ✅ Cython 源码（.pyx）
    ├── seqdss.pyx                 ✅ Cython 源码（.pyx）
    ├── seqdur.pyx                 ✅ Cython 源码（.pyx）
    ├── seqlength.pyx              ✅ Cython 源码（.pyx）
    └── get_sm_trate_substitution_cost_matrix.pyx ✅ Cython 源码
```

### ❌ 不应该 Commit（编译产物）

```
sequenzo/dissimilarity_measures/
├── __pycache__/                   ❌ Python 字节码缓存
├── c_code.cpython-*.so            ❌ 编译后的二进制
├── build/                         ❌ 编译临时文件
│   ├── lib.*/
│   └── temp.*/
└── utils/
    ├── seqconc.c                  ❌ Cython 生成的 C 代码
    ├── seqconc.cpython-*.so       ❌ 编译后的二进制
    ├── seqdss.c                   ❌ Cython 生成的 C 代码
    ├── seqdss.cpython-*.so        ❌ 编译后的二进制
    ├── seqdur.c                   ❌ Cython 生成的 C 代码
    ├── seqdur.cpython-*.so        ❌ 编译后的二进制
    ├── seqlength.c                ❌ Cython 生成的 C 代码
    ├── seqlength.cpython-*.so     ❌ 编译后的二进制
    ├── get_sm_trate_substitution_cost_matrix.c  ❌ Cython 生成的 C 代码
    └── get_sm_trate_substitution_cost_matrix.cpython-*.so ❌ 编译后的二进制
```

---

## 详细解释

### 1. 什么是源代码 vs 编译产物？

#### 源代码（Source Code）- 应该 commit
- 人类编写的代码
- 可读、可维护
- 平台无关
- 例子：`.py`, `.pyx`, `.cpp`, `.h`

#### 编译产物（Build Artifacts）- 不应该 commit  
- 机器生成的文件
- 二进制格式，不可读
- **平台相关**（x86_64, arm64, Windows, macOS, Linux）
- **环境相关**（包含硬编码路径）
- 例子：`.so`, `.pyd`, `.o`, Cython 生成的 `.c`

---

## 为什么 `.pyx` 可以 commit，但 `.c` 不行？

### `.pyx` 文件（✅ 应该 commit）

```python
# seqconc.pyx - 这是你写的源代码
import numpy as np
cimport numpy as np

def seqconc(np.ndarray seq, str sep="-"):
    """将序列拼接成字符串"""
    # ... 你的代码逻辑 ...
```

**特点：**
- 人类编写，可读
- 包含业务逻辑
- 平台无关
- 这是"真正的代码"

### `.c` 文件（❌ 不应该 commit）

```c
// seqconc.c - 由 Cython 自动生成，6000+ 行
/* Generated by Cython 3.1.4 */

// 硬编码的路径（问题所在！）
{
    "include_dirs": [
        "/Users/lei/Documents/Sequenzo_all_folders/sequence_data_sources/.conda/lib/python3.12/site-packages/numpy/_core/include",
        ...
    ],
    "extra_compile_args": [
        "-arch", "x86_64",  // 只针对你的电脑架构
        ...
    ]
}

// 6000+ 行机器生成的代码...
static PyObject *__pyx_pf_8seqconc_seqconc(...) {
    // 编译器优化后的代码，不可读
}
```

**特点：**
- 机器生成，不可读（6000+ 行）
- 包含硬编码路径（你的 conda 环境）
- 包含架构特定信息（x86_64 或 arm64）
- 用户电脑上路径不一样 → 编译失败

---

## 为什么手写的 `.cpp` 可以 commit？

### 手写的 C++ 源码（✅ 应该 commit）

```cpp
// src/OMdistance.cpp - 手写的 C++ 代码
#include <pybind11/pybind11.h>
#include <pybind11/numpy.h>

namespace py = pybind11;

double compute_om_distance(py::array_t<int> seq1, py::array_t<int> seq2) {
    // 你的算法逻辑
    // 计算 Optimal Matching 距离
    return distance;
}

// Pybind11 绑定
PYBIND11_MODULE(c_code, m) {
    m.def("compute_om_distance", &compute_om_distance, "计算 OM 距离");
}
```

**特点：**
- 你自己写的代码，包含业务逻辑
- 不包含硬编码路径
- 不包含架构特定代码
- 编译时会根据用户的系统自动适配

### Cython 生成的 `.c`（❌ 不应该 commit）

```c
// utils/seqconc.c - Cython 自动生成
// ⚠️ 包含你的电脑的路径！
"include_dirs": [
    "/Users/lei/Documents/.../sequence_data_sources/.conda/lib/python3.12/..."
]
```

**问题：**
- 用户的电脑没有 `/Users/lei/Documents/...` 这个路径
- 用户可能是 Windows（路径格式完全不同）
- 用户可能是 ARM Mac（架构不同）

---

## 为什么以前没问题，现在有问题？

### 场景分析

#### 情况 1：以前用户也遇到过问题，只是没报告
- 可能只有少数用户遇到
- 他们可能自己解决了（重新编译）
- 或者放弃了使用

#### 情况 2：最近环境变化更大
- **NumPy 2.0 发布**（2024年）→ ABI 变化更大
- **Python 3.12 新版本** → 更严格的检查
- **Apple Silicon (M1/M2/M3)** → 架构不同（arm64 vs x86_64）
- 用户环境更多样化了

#### 情况 3：之前的 .c 文件碰巧能用
- 如果 `.c` 文件是在通用环境生成的（比如 CI）
- 路径问题可能不明显
- 但现在你本地生成的包含特定路径

### 具体例子

**之前（可能侥幸能用）：**
```c
// 在 CI 环境生成的 .c 文件
"include_dirs": [
    "/opt/hostedtoolcache/Python/3.11.0/x64/include"  // CI 标准路径
]
```
→ 用户编译时可能碰巧能找到类似路径

**现在（肯定不能用）：**
```c
// 在你本地 Mac 生成的 .c 文件
"include_dirs": [
    "/Users/lei/Documents/Sequenzo_all_folders/sequence_data_sources/.conda/lib/python3.12/..."
]
```
→ Windows 用户完全找不到这个路径

---

## 正确的工作流程

### 开发阶段

```bash
# 1. 修改源代码
vim sequenzo/dissimilarity_measures/utils/seqconc.pyx

# 2. 本地测试（会生成 .c 和 .so 文件）
python setup.py build_ext --inplace

# 3. 测试功能
python -c "from sequenzo.dissimilarity_measures.utils import seqconc; ..."

# 4. 只 commit 源代码
git add sequenzo/dissimilarity_measures/utils/seqconc.pyx
git commit -m "优化 seqconc 函数性能"

# ❌ 不要 commit .c 和 .so 文件！
# .gitignore 会自动忽略它们
```

### 发布阶段（CI/CD）

```yaml
# .github/workflows/python-app.yml
steps:
  - name: Build wheels
    run: |
      # Cython 会自动从 .pyx 生成新的 .c 文件
      # 这些 .c 文件在 CI 环境生成，包含正确的路径
      python -m cibuildwheel
```

**结果：**
- 每个平台（macOS/Windows/Linux）生成自己的 `.c` 文件
- 每个架构（x86_64/arm64）生成自己的二进制
- 打包到 wheel 里分发给用户

---

## 检查清单

### Commit 前检查

```bash
# 1. 查看准备 commit 的文件
git status

# 2. 检查是否有不该 commit 的文件
git diff --cached | grep "\.c$"   # 应该没有 .c 文件
git diff --cached | grep "\.so$"  # 应该没有 .so 文件

# 3. 查看当前 tracked 的文件
git ls-files | grep "utils/.*\.c$"
# 如果有输出 → 需要 untrack：
# git rm --cached sequenzo/dissimilarity_measures/utils/*.c
```

### .gitignore 设置

```gitignore
# ✅ 正确的配置
*.c           # 忽略所有 .c 文件
*.so          # 忽略所有 .so 文件
*.pyd         # 忽略所有 .pyd 文件（Windows）
*.o           # 忽略所有 .o 文件
__pycache__/  # 忽略 Python 缓存
build/        # 忽略构建目录

# 但保留手写的 C++ 源码
!sequenzo/dissimilarity_measures/src/*.cpp
!sequenzo/dissimilarity_measures/src/*.h
!sequenzo/clustering/src/*.cpp

# ❌ 不要这样做！
# !sequenzo/dissimilarity_measures/utils/*.c  # 这会允许 Cython 生成的 .c 文件
```

---

## 文件类型总结

| 文件类型 | 例子 | Commit? | 说明 |
|---------|------|---------|------|
| Python 源码 | `.py` | ✅ | 人类编写，平台无关 |
| Cython 源码 | `.pyx` | ✅ | 人类编写，平台无关 |
| 手写 C++ 源码 | `src/*.cpp` | ✅ | 人类编写，平台无关 |
| 头文件 | `.h`, `.hpp` | ✅ | 人类编写，平台无关 |
| Cython 生成的 C | `utils/*.c` | ❌ | 机器生成，包含硬编码路径 |
| 编译后的二进制 | `.so`, `.pyd` | ❌ | 平台相关，架构相关 |
| Python 字节码 | `.pyc` | ❌ | Python 版本相关 |
| 构建临时文件 | `build/`, `*.o` | ❌ | 编译过程临时文件 |

---

## 为什么 PyPI wheel 里有二进制文件？

这是**打包后的产物**，不是源代码仓库：

```bash
# 下载 wheel 文件
pip download sequenzo

# 解压查看
unzip sequenzo-0.1.19-cp311-cp311-macosx_11_0_universal2.whl
# 里面包含编译好的 .so 文件
# 但这些是在 CI 为特定平台编译的
```

**区别：**
- Git 仓库 = 源代码 + 构建配置
- Wheel 文件 = 编译后的二进制（平台特定）

---

## 相关资源

- [Cython 文档 - Source Files](https://cython.readthedocs.io/en/latest/src/userguide/source_files_and_compilation.html)
- [Python Packaging Guide](https://packaging.python.org/en/latest/guides/distributing-packages-using-setuptools/)
- [What to gitignore in Python projects](https://github.com/github/gitignore/blob/main/Python.gitignore)

